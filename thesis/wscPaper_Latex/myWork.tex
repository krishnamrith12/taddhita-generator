%
% File Skt_and_IT_WSC16.tex
%
% Contact: apksh@uohyd.ernet.in (ambapradeep@gmail.com)
%%
%% Based on the style files for COLING2014, which were, in turn,
%% Based on the style files for ACL-2014, which were, in turn,
%% Based on the style files for ACL-2013, which were, in turn,
%% Based on the style files for ACL-2012, which were, in turn,
%% based on the style files for ACL-2011, which were, in turn, 
%% based on the style files for ACL-2010, which were, in turn, 
%% based on the style files for ACL-IJCNLP-2009, which were, in turn,
%% based on the style files for EACL-2009 and IJCNLP-2008...

%% Based on the style files for EACL 2006 by 
%%e.agirre@ehu.es or Sergi.Balari@uab.es
%% and that of ACL 08 by Joakim Nivre and Noah Smith

\documentclass[11pt]{article}
\usepackage{scl}
\usepackage{times}
\usepackage{url}
\usepackage{latexsym}
\usepackage{graphicx}
\usepackage{amssymb} 
\usepackage{times}
\usepackage{latexsym}
\usepackage{caption}
\usepackage{subcaption}

%% You can use devanagari script within this document after uncommenting the packages fontspec, xunicode and xltxtra with mentioning your unicode font name into next line.
%% You can use any Devanagari Unicode/UTF-8 font for Devanagari texts. For that replace the font name `Sanskrit 2003' with your font name in below line `\newfontfamily\skt[Script=Devanagari]{Sanskrit 2003}' such as if you are using `Mangal' unicode font then your line shoule be like `\newfontfamily\skt[Script=Devanagari]{Mangal}' or if you want to use the same line as it is then you should have installed `Sanskrit 2003' font on your machine.
%% To give your text(s) into Devanagari you have to use the command \skt{TEXT into UNICODE/UTF-8} such as \skt{परिचयः}. See the below examples in devanagari.
%% while using devanagari script, you have to compile your latex code with `xelatex' command instead of pdflatex/latex etc. 

\usepackage{fontspec, xunicode, xltxtra}
\newfontfamily\skt[Script=Devanagari]{Sanskrit 2003}

%\setlength\titlebox{5cm}

% You can expand the titlebox if you need extra space
% to show all the authors. Please do not make the titlebox
% smaller than 5cm (the original size); we will check this
% in the camera-ready version and ask you to change it back.


\title{Towards automating the generation of derivative nouns in Sanskrit by simulating Pāṇini}

\author{Amrith Krishna \\
  Department of CSE, \\
  Indian Institute of Technology, \\
  Kharagpur, India \\
  {\tt amrith.krishna@cse.iitkgp.ernet.in} \\\And
  Pawan Goyal \\
  Department of CSE, \\
  Indian Institute of Technology, \\
  Kharagpur, India \\
  {\tt pawang@cse.iitkgp.ernet.in} \\}

\date{}

\begin{document}
\maketitle
\begin{abstract}
About 1115 rules in Aṣṭādhyāyī from {\sl A.4.1.76} to {\sl A.5.4.160} deal with generation of derivative nouns, making it one of the largest topical sections in Aṣṭādhyāyī, called as the Taddhita section owing to the head rule {\sl A.4.1.76}. This section is a systematic arrangement of rules that enumerates various affixes that are used in the derivation under specific semantic relations. We propose a system that automates the process of generation of derivative nouns as per the rules in Aṣṭādhyāyī. The proposed system follows a completely object oriented approach, that models each rule as a class of its own and then groups them as rule groups. The rule groups are decided on the basis of selective grouping of rules by virtue of {\sl anuvṛtti}. The grouping of rules results in an inheritance network of rules which is a directed acyclic graph. Every rule group has a head rule and the head rule notifies all the direct member rules of the group about the environment which contains all the details about data entities, participating in the derivation process. The system implements this mechanism using multilevel inheritance and observer design patterns. The system focuses not only on generation of the desired final form, but also on the correctness of sequence of rules applied to make sure that the derivation has taken place in strict adherence to Aṣṭādhyāyī. The proposed system's design allows to incorporate various conflict resolution methods mentioned in authentic texts and hence the effectiveness of those rules can be validated with the results from the system. We also present cases where we have checked the applicability of the system with the rules which are not specifically applicable to derivation of derivative nouns, in order to see the effectiveness of the proposed schema as a generic system for modeling Aṣṭādhyāyī. 
 
\end{abstract}

\section{Introduction}

Aṣṭādhyāyī, the central part of Pāṇini's grammar, is a classic and seminal work on descriptive linguistics. Aṣṭādhyāyī provided a complete description of the Sanskrit language spoken at that time period, and is also often praised for the computational principles and programming concepts used in it. Approximately one fourth (about 1115) of rules in Aṣṭādhyāyī deal with generation of derivative nouns (and adjectives), which are derived by affixation from other nouns (or adjectives). The affixes that are used for derivation of derivative nouns are enumerated in the Taddhita section of Aṣṭādhyāyī and hence the affixes that come under this section are called Taddhita. Taddhita section starts with rule {\sl A.4.1.76} { \skt तद्धिताः} of Aṣṭādhyāyī which is an adhikāra rule and its influence is till the end of fifth chapter i.e. {\sl A.5.4.160} {\skt निष्प्रवाणिः च}. Though Pāṇini did not provide any semantic definition for Taddhita, it is based on rule {\sl A.5.1.5} {\skt तस्मै हितम्} which means ``beneficial to that'' \cite{bhate89}, where ``that''({\skt तस्मै}) is intended for the base nominal from which the derivation will take place. Aṣṭādhyāyī considers both nouns and adjectives as a single category called as Prātipadika ({\skt प्रातिपदिक}), and hence the affixes used in Taddhita are not category changing affixes \cite{deo07}.
\\ \\
Though Aṣṭādhyāyī was intended for human understanding and usage, our work attempts to automate the process of deriving Taddhitas in complete adherence to Aṣṭādhyāyī. Our work, not only aims to generate the correct final form from any given nominal but also to follow the sequence of rules applied as per Aṣṭādhyāyī in the derivation process. Hence the work requires to automate rules in Aṣṭādhyāyī that deal with Taddhita section as well as other associated rules, which help in the derivation process.
\\
The proposed system adopts a completely object oriented approach in modeling Aṣṭādhyāyī. The rules of Aṣṭādhyāyī are modeled as classes and so is the environment that contains the entities for derivation. The rules are then grouped based on the notion of topicality by virtue of anuvṛtti. In our proposed system the rule group formation is achieved through formation of inheritance network i.e. multilevel inheritance formed between individual rule classes, which has been inspired from the inheritance network that Pāṇini used in Aṣṭādhyāyī \cite{deo07}. Pāṇini uses anuvṛtti to carry forward the inherited components to child rules, though it needs to be noted that signifying of the inheritance is one of the aspects of anuvṛtti, and hence our proposed model does not form the inheritance network over all the usages of anuvṛtti, but rather a subset of it. The principles discussed in Aṣṭādhyāyī that enable rule selection and rule application like {\sl A.1.4.2} {\skt विप्रतिषेधे परं कार्यम्}, {\sl siddha} and {\sl asiddha} are built right into the core architecture of proposed system. In addition to these principles, the system provides a functionality to adopt different conflict resolution methods that are discussed outside of Aṣṭādhyāyī. The system does not restrict itself by adopting any particular conflict resolution method, instead it facilitates to try out various methods that have been mentioned in various scholarly works. This will thus help to evaluate various methods and report on their accuracy as no single set of conflict resolution methods has gained consensus among the scholars.
\\
The rest of the paper is organized as follows. In Section \ref{sect:related}, we will be discussing about various attempts towards formalizing rules of Aṣṭādhyāyi, and modeling Aṣṭādhyāyi in part or full to a automated system. In Section \ref{intro}, we will look into the linguistic and structural features of Taddhita section. We will be discussing about various linguistic characteristics that the affixes in the domain possess. We will also be looking into the arrangement of rules in Taddhita section and how the arrangement forms an inheritance hierarchy. In Section \ref{sect:imple} we will be describing the working of the proposed system, tools and techniques used for the implementation and also modeling of data environment and rule classes. Section \ref{sect:egderi} will show a step by step derivation of a nominal from another base noun. Section \ref{sect:gen} will show the applicability of the proposed schema as a general framework to model entire Aṣṭādhyāyi by considering how the proposed system handles rules that are not specific to the derivation of a derivative noun. Section \ref{chapter 5} details about the evaluation framework and results. The section also presents some analysis of incorrect cases and other special instances that we encountered in our system. Finally, Section \ref{sect:conc} discusses the bottlenecks in automating the Aṣṭādhyāyi that we encountered during the implementation of our system, salient features and application domains of the system along with directions for future work.


\section{Related Work}
\label{sect:related}
Aṣṭādhyāyi has received much attention from computational linguists from the latter half of
20th century. Aṣṭādhyāyi was much lauded for its brevity, completeness and computational
insights it provides. There have been works from eminent scholars about the formalism of Pāṇini’s Grammar, its expressive power, and the derivation process (prakriyā) it follows. Seminal works from \newcite{cardona65} and \newcite{staal65}  on formalizing rules of the grammar with stress on the meta-rules that state about the context sensitive aspects was a starting point with further enhancements from \newcite{cardona69} where he applies his formalization for more rules that is related to phonetic changes. 
\\ \\
\newcite{cardona07} highlights the relevance of affixation and how it is well integrated with syntax as a continuum in Pāṇini’s derivational system. He points out the contrast that Pāṇini’s system bears with the system that western grammarians follow, where morphology and syntax are treated as independent components in derivation. \newcite{kiparsky12} focus on the expressive power of
Aṣṭādhyāyi rules and also the expressive power of formalism that Pāṇini used to design
Aṣṭādhyāyi. They demonstrate that the formalism of the grammar has far more expressive power than that of regular languages and Context Free Languages. Their work emphasizes on the power of formalism that has built-in capacity for disambiguation at syntactic level. \newcite{hyman07} developed a finite state transducer after re-framing individual rules in Aṣṭādhyāyi, resulting in generation of strings that belong to regular languages and performs sandhi ({\skt सन्धि}) at word boundaries for any two given word combinations. Hyman had introduced an XML vocabulary for encoding rules in Aṣṭādhyāyi that helped him in implementing the finite state transducer. \newcite{scharf09c} discusses about Scharf's and Hyman's combined efforts in developing XML formalization that not only deals with sandhi but also with nominal declensions and verb conjugations. 
\\ \\
There have been various attempts to automate Aṣṭādhyāyi in parts as well as modeling it entirely. \newcite{goyal07} implemented an inflectional morphology generator that takes as input a noun
from the user and then generates all 21 forms of noun declensions, known as {\sl vibhakti}
system in Sanskrit grammar. The authors talk about the programming perspectives that need to be
considered when encoding rules in Aṣṭādhyāyi, and various computational aspects that
Aṣṭādhyāyi possesses. They also talk about the need of conflict resolution methods for competing
rules that can be applied in the same context. \newcite{jha07} have developed a system that is an
inflectional morphology analyser. They have developed independent systems for verb and noun
forms and their corresponding inflections. Though their work was not related to simulating  Aṣṭādhyāyi, but they claim that they take into account the Pāṇinian way of analysis.   \newcite{kumar14} takes on generation of
Sanskrit compounds called as samāsa that deals with about 400 rules of Aṣṭādhyāyi which helps them
to form compound words from independent words in Sanskrit. Their work talks about various kinds of semantic features that act as the constraints governing compound formation.

\\ \\
\newcite{subbanna09} have talked in length about the Computational Structure of the Aṣṭādhyāyi, and introduced the concept of rules that continuously observe the environment or the subject to which modifications are to be made. They have also talked about {\sl Siddha,Assidhavat and Asiddha } principles used in Aṣṭādhyāyi.There has been an in-depth study on {\sl siddha and asiddha} principles by \newcite{joshi87}, where they talk about the order in which rules need to be applied. \newcite{subbanna09} mentioned about the grouping of rules based on the general-exception relation between rules and formation of rules as a tree structure, but commented that the feasibility of automation needs to be checked. They also talk about various conflict resolution methods that are mentioned in the sūtras as well as in other vārttikas. \newcite{subbanna10} presented a computational model based on the principle of {\sl asiddhatva}, an improvised model over the one discussed in \newcite{subbanna09}. \newcite{mishra07} talks of the nature of grammar which performs the analysis of constituent elements and then its reconstitution using various set of operational rules as mentioned in Aṣṭādhyāyi. \newcite{mishra10} in his work discusses about {\sl vedāṅga } principles and extends his work by considering the common methodological approach of ancillary disciplines for rule application. His work provides a good walk-through for the entire derivation process that begins with introduction of atomic elements to coming up with the desired final form. \newcite{kulkarni09} establishes the issue with phonological over-generation that can occur, if one is to strictly adhere to the rules defined by Pāṇini. \newcite{skmishra09} sheds some light in formalizing semantic categorization rules when he deals with kāraka systems. These kind of issues have been a matter of debate among linguists for quite long. Many principles that are not stated in Aṣṭādhyāyī but in other texts written at various points of time have surfaced to deal with such issues, mainly those which concern about conflict resolution in rule selection. \newcite{cardona97} discusses about various principles like {\sl utsarga-apāvada}, {\sl antaraṅga-bahiraṅga}, {\sl nitya-anitya} etc. in detail.
\\ \\
When it comes to automating Taddhitas, the Sanskrit Heritage System is an existing system that can recognize taddhitas and perform the analysis, but it does not generate the Taddhitas and only the lexicalized Taddhitas are recognized during the analysis \cite{goyal2013}. To the best of the authors' knowledge, the system which we are going to propose is the first of its kind, that is focused specifically on generation of derivative nouns (Taddhitas). 
 The proposed system embraces a unique approach of forming rule groups where similar rules are grouped together to form a Directed Acyclic Graph (DAG). The similarity of rules is based on the notion of topicality present among the rules by virtue of usage of anuvṛtti. The approach can be treated as analogous to the model, what is proposed in \newcite{subbanna09}, but they propose the formation of similar topic DAG through utsarga-apāvada relations. One cannot comment on the similarity of the approaches without a proper comparison of DAGs formed from both of them. Moreover \newcite{subbanna09} mentioned that they had not checked the feasibility of automating their notion of rule group formation. Another important feature that our system uses is that it automatically notifies the relevant rule classes whenever the data environment state changes. This eliminates the overhead of linear searching over each rule, or each rule polling the environment to find its application. Instead the mechanism allows the rules to be updated about environment state changes whenever there is one and yet the rule classes can refrain from state dependency issues with the environment \cite{szallies1997using}. 

\section{Linguistic and Structural aspects of Taddhita Section}
\label{intro}


In the Taddhita section, Pāṇini identifies about 300 semantic relations under which Prātipadikas can be generated with Taddhita affixes. It is mentioned as a sub-section to {\sl pratyayādhikāra} that deals with all kinds of affixes. The rules in Taddhita section deal with three entities namely semantic relations, affixes and stems or collection of stems from {\sl gaṇapāṭha}. The rules are defined in such a way so as to facilitate affixation of the proper Taddhita affix with respect to semantic relation intended. The rules often deal with properties of the entities involved at various levels from phonological, morphological, syntactic and semantic levels. There are two types of derivations possible that involve Taddhita affixes \cite{rsbook}.

\\ \centerline{Prātipadika + Taddhita-affix} \\ \centerline{Prātipadika + Taddhita-affix + strī-affix} 

\\
\subsection{Linguistic Phenomena in Derivational Morphology}

Derivational morphology in Sanskrit, like in many other languages poses some of the well
known facts about many to many correspondences between forms and affixes. Taddhita affixes exhibit affix polysemy, homonymy, synonymy and non-compositionality. In affix polysemy, the same
affix is used to denote related senses like in the case of patronymic and provenance relation. In affix homonymy the same affix is used in distinct and unrelated semantic contexts like in the case of personal nouns or abstract nouns. Affix synonymy deals with the same semantic sense but
uses different affixes. For example, for the patronymic relation {\skt अपत्यम्}, multiple affixes can be used, like {\skt अ(ण्), अयन(फक्), इ(ञ्)} depending on the stems used \cite{deo07}.
\\
\subsection{Organization of Taddhita rules}
\label{orgTad}
Taddhita section is primarily subdivided into five {\sl pratyayādhikāras} or domain of control
of five pratyayas.
\renewcommand{\labelitemi}{$\blacksquare$}
\begin{itemize}
  \item The five rules are:
\renewcommand{\labelenumi}{$\Roman{enumi}$}
\begin{enumerate}


  \item {\sl A.4.1.83} {\skt प्राक् दीव्यतः अण् } - {\skt अण् } suffix is the default affix to be used for affixation for all the rules till {\sl A.4.4.1}. The influence of {\sl A.4.1.83} is till the term {\skt दीव्यति} is found (or till another pratyayādhikāra is found) and {\skt दीव्यति} appears in rule {\sl A.4.4.2} {\skt  तेन दीव्यति खनति जयति जितम्}. 
  \item {\sl A.4.4.1} {\skt  प्राक् वहतेः ठक् । } - {\skt ठक् } suffix is the default affix to be used for affixation for all the rules till {\sl A.4.4.76}. {\skt  वहति} appears in rule {\sl A.4.4.76} {\skt तत् वहति रथयुगप्रासङ्गम्}.
  \item {\sl 4.4.75} {\skt प्राक् हितात् यत् } - {\skt यत् } is the default affix to be used for affixation for all the rules till {\sl A.5.1.5}.{\skt हितम्} appears in rule {\sl 5.1.5} {\skt  तस्मै हितम्}. 
  \item {\sl 5.1.1} {\skt  प्राक् क्रीतात् छः } - {\skt छः } is the default affix to be used for affixation for all the rules till {\sl A.5.1.37 }{\skt  क्रीतम्} appears in rule {\sl 5.1.37} {\skt तेन क्रीतम्}.
  \item {\sl 5.1.18} {\skt प्राग् वतेः ठञ् } - {\skt ठञ् }is the default affix to be used for affixation for all the rules till {\sl A.5.1.115}. {\skt वतिः} appears in rule {\sl 5.1.115} {\skt  तेन तुल्यं क्रिया चेत् वतिः }. 
  
\end{enumerate}
\end{itemize}

\begin{figure}[h]
    \centering
	\includegraphics[width=0.8\textwidth]{tad}
    \caption{An instance of inheritance hierarchy in Taddhita section}
    \label{fig:inheritance}
\end{figure}


Now each of the above given rules, which can be called as the pratyayādhikāra rules, specifies what is the most prominent affix or the default case affix that can be applied to all the rules which are under its domain. For the set of rules under a single pratyayādhikāra, they are further categorized on the basis of arthādhikāra rules. Each arthādhikāra heads a set of rules which are a proper subset of rules that come under the pratyayādhikāra. The arthādhikāra rules state the semantic conditions or the semantic rules under which the default affix can be attached. Arthādhikāra rules serve the purpose of a topic head that groups a set of rules as a rule group based on a topic, which is a semantic relation here and it also acts as an operational rule ({\skt विधि}), as it carries the semantic sense under which the affix can be attached. Rules {\sl A.4.1.92} {\skt तस्य अपत्यम्}, {\sl A.4.2.1} {\skt तेन रक्तं रागात्}, {\sl A.4.2.69} {\skt तस्य निवासः} etc. denote the semantic senses such as patronymic, ``coloured by means of that'' and provenance respectively. This kind of arrangement handles affix polysemy and affix homonymy. But to handle affix synonymy, there are other operational rules, that come under the domain of arthādhikāra rules. They can be seen as exception rules or rules to handle special cases. These rules limit the application of default affix specified in pratyayādhikāra and mention what other affixes can be used instead, under special conditions. In this way, affix synonymy and non-compositionality is taken care of.\\ 
\newcite{deo07} calls this form of arrangement as constrained separationism, where the rules form a multilevel single inheritance network. The template for the multilevel inheritance network will be of the type, ``Default Affix rule'' -``Semantic Sense rule'' - ``Special case rules''. Figure \ref{fig:inheritance} shows an instance of how the hierarchy in Taddhita works. As already discussed, {\sl A.4.1.83} states about the default affix {\skt अण्} for rules under its domain, {\sl A.4.1.92 }states about the patronymic relation under which a nominal will get the default affix. Now rule {\sl A.4.1.128} states about a special case when the stem {\skt चटका} is used with the patronymic relation. In such a case the suffix {\skt ऐरक्} needs to be attached. This rule overrides the default case rule. Now consider rule {\sl A.4.4.25.} This rule talks about usage of {\skt अण्} as an exception or special case when a stem {\skt मुद्ग} is used. The rule has {\sl A.4.4.1} as its default affix rule and the default affix for the domain is {\skt ठक्}. The rule's semantic sense is {\skt संसृष्टे}, which means `properly mixed with'. Here the rule {\sl A.4.4.25} accounts for the non-compositionality of the affix {\skt अण्} and is not specified in its domain but as an exception rule in another default affix domain.
\\
It is to be noted that there are some more rules in the Taddhita section which do not come under any of the five pratyayadhikāra rules. Those rules have arthādhikāras of their own but has no default affix to be attached. This group of rules is treated as extraneous to otherwise systematic network of the section \cite{bhate89}. As we will be discussing about the implementation schema of proposed generation system in the subsequent section, it will become evident that this anomaly in no way is going to affect the system.
  





\section{Implementation}
\label{sect:imple}

\subsection{Derivational Process}
\label{sect:intro-deri}

In order to discuss about the derivation process or ({\skt प्रक्रिया}) of a derivative noun, let us take the derivation of derivative noun {\skt औपगव} from the nominal {\skt उपगु  }, which can be considered as the 	``Hello world'' in Taddhita section. The essential steps in the derivation process are shown in Table ~\ref{derivation-table}. {\skt औपगव} which means son of upagu, comes from the semantic sense {\skt अपत्यं} by the rule 4.1.92 {\skt तस्य अपत्यम्}, and the correct Taddhita affix {\skt अण् } is introduced to the environment. Once the Taddhita affix is introduced, what remains is a series of operations on the environment that results in a final form. The rules so triggered may be seen as a continuous iteration of two sub-processes. One is identification and assignment of technical terms ({\skt संज्ञा}) to the environment string or to a relevant substring of it. By this, the environment does not get modified but gains the technical term as an attribute. The interpretive rules assign the technical terms to the environment and those rules are shown in the first column of Table ~\ref{derivation-table}. Now, by virtue of these attributes, the environment gets modified through operational rules that come within the domain of attributes as shown in the third column of Table ~\ref{derivation-table}. The effect of the rule on the environment can be seen in the second column. Triggering of operational rules is the second sub-process in the iteration and the derivation process stops when no more attributes can be attributed to the environment. Ideally, by that time the desired form must be derived. 

\begin{table}[h]
\begin{center}
\resizebox{\textwidth}{!} {
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|l|c|r|}
\hline \bf Interpretational terms to be assigned & \bf Derivation environment & \bf Operation rule to be applied \\ \hline
 & {\skt उपगोः अपत्यं} &  \\ \hline
 & { \skt उपगु ङस् अपत्यं } & \\ \hline
  { \skt तद्धित } (4.1.76 {\skt तद्धिताः}) & & \\ & & 4.1.92 {\skt तस्य अपत्यम् } \\
& {\skt उपगु ङस् अण्} & \\ \hline 
{\skt इत् } (1.3.3 { \skt हलन्त्यम्}) & & \\
& &  1.3.9 { \skt तस्य लोपः}  \\
& { \skt उपगु ङस् अ} &   \\ \hline

{\skt प्रातिपदिकम् } (1.2.46 { \skt कृत्तद्धितसमासाः च}) &  &  \\

&  & 2.4.71  { \skt सुपः धातुप्रातिपदिकयोः }  \\
&  { \skt उपगु अ } &  \\ \hline
{ \skt अङ्गम् } ( 1.4.13 { \skt यस्मात् प्रत्ययविधिः तदादि प्रत्यये अङ्गम् } ) & &  \\
&  & 7.2.117 { \skt तद्धितेषु अचाम् }  \\
&  { \skt औपगु अ } &  \\ \hline
{ \skt भ } ( 1.4.18 { \skt यचि भम् } ) & &  \\
&  & 6.4.146 { \skt  ओः गुणः }  \\
&  { \skt औपगो अ } &  \\\hline
{ \skt संहिता } ( 1.4.109 { \skt परः सन्निकर्षः संहिता } ) & &  \\
&  &  6.1.78 { \skt एचः अयवायावः }  \\
&  { \skt औपगव् अ } &  \\ \hline

&  { \skt औपगव } &  \\ \hline

\hline
\end{tabular}
}
\end{center}
\caption{\label{derivation-table} Derivation Process for { \skt औपगव }. Here each horizontal line partition represents one step in the derivation, where one of the operations among insertion, elision or substitution takes place in column 2. Column 1 shows assignment of some technical term, and column 3 shows subsequent operation after gaining the technical term as a property. Column 2 shows the effect due to the operation. In column 2 we can see the effect of the rules on the environment, where an insertion, elision or substitution takes place.  }
\end{table}
\\
\subsection{Overview of the Implementation System }
\label{sect:impl}

For automating the derivation process, we suggest the following method
which is based on object oriented concepts. Each rule forms a class and each instance of the rule class (henceforth to be referenced as rule itself) is registered
with the environment, such that whenever there is a change in the environment, the rules are
notified. Each rule checks for the possibility of it being applied on the environment and for a rule, if all its conditions are satisfied, ideally the rule can be applied on the environment. However, in a general scenario multiple rules may claim their competency for application on the environment. To handle such scenarios we keep those competing rules in a list called candidate list. Then a conflict resolution method is employed which decides the winner rule. The winner rule gets to apply on the environment and other rules are removed from list. By removal of rules other than the winner rule, we mean that the removed ones are not applied on the present instance of environment, although they are notified when the environment change happens again. Figure \ref{fig:impl-fig} shows the schema of the implementation system.

\begin{figure}[h]
    \centering
	\includegraphics[width=\textwidth]{impl}
    \caption{Overview of Implementation System}
    \label{fig:impl-fig}
\end{figure}
\\
As it is evident from discussion about Taddhita section, Pāṇini among various applications of anuvṛtti, uses it for carrying the topicality between different rules as well. It is to be noted that adhikāra rules are rules whose sole purpose is mentioning the topicality of the rules under its domain of influence. But even for adhikāra rules, anuvṛtti itself is used for carrying the domain's influence to other rules. Apart from the adhikāra rules, there are other rules as well in which anuvṛtti is used to carry the topicality. For example consider the rules concerning {\skt  इत्}, i.e. rules from 1.3.2 to 1.3.8. Here {\skt उपदेशे and इत्} are being carried forward to other rules as well. {\skt उपदेशे}, which means `when an upadeśa is encountered', perform some action. This condition leads to a common topicality for all the rules under the anuvṛtti. This is similar to the notion of arthādhikāra rules in Taddhita where the notion of semantic sense is being carried forward to subsequent rules through anuvṛtti. Both the techniques, anuvṛtti and adhikāra are employed in the entire Aṣṭādhyāyī and are not unique to the Taddhita section. We can infer that a subset of the anuvṛtti rules, mostly the ones which carry the notion of topicality can be used to design an inheritance hierarchy of classes. For the implementation we will be using this notion of topicality via anuvṛtti, in grouping of rules to form rule groups which is an inheritance hierarchy among rules and the rule in which the portion of anuvṛtti appears, becomes the head rule.
\\
\subsection{Tools and Techniques Used}
\label{sect:tools}
We are following a completely object oriented approach for the implementation of the system.
The following tools and techniques will be employed to achieve the principles discussed in section ~\ref{sect:impl} 

\\
\subsubsection{Observer Design Patern}
Observer design pattern defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically \cite{obs}. The object on which the state changes occur is called subject and it maintains a list of its dependents, called observers. As shown in Figure \ref{fig:obsUML}, each observer object which is the sūtra or rule in our case, is registered to an object called as “Subject” class which represents the environment in our case. Subject class has a method to register the observers. Whenever a change in value of some attribute of subject occurs, it calls the method `notify' of observer abstract class, which is implemented for each object of the Observer.

\begin{figure}[h]
    \centering
	\includegraphics[width=\textwidth]{obsUML}
    \caption{UML diagram for observer design pattern}
    \label{fig:obsUML}
\end{figure}

\\
\subsubsection{Multilevel Inheritance}

To form rule groups i.e. inheritance network among rules we use multilevel inheritance between the rules. Though multilevel inheritance is allowed, multiple inheritance is not allowed in the system and hence no single rule will inherit from two distinct rules directly. Figure \ref{fig:UMLinher}
shows the inheritance achieved for each class in Aṣṭādhyāyī. All classes inherit from a base class
called ``sūtra'', which is a generic class that defines all possible features that a rule or sūtra can possess. All other rules inherit from it. The adhikāra rules, anuvṛtti of interpretive rules, default condition rules etc. form super class for other operational rule classes. 

\begin{figure}[h]
    \centering
	\includegraphics[width=0.2\textwidth]{UMLinher}
    \caption{UML diagram for multilevel inheritance}
    \label{fig:UMLinher}
\end{figure}


\\
\subsection{Rule Triggering and Propagation}
The environment forms the subject class for the observer design pattern. However, not all rules are
observing the environment but only those rules that do not come under the domain of any adhikāra rules or a controlling head of a rule group through anuvṛtti (which are mostly rules that assigns the technical terms to assignments). Those are represented by classes R1, R2 and so on in Figure \ref{fig:fullImp}. Then there are rule groups as represented by RG1, RG2 and so on. These are collections of rules with same head. The rule classes that come under the same head in the group, inherit from the head rule class. The head rule object, as per observer design pattern registers the inherited classes' objects as observers. Now the head class notifies the observers whenever the environment satisfies the head rule's conditions. The conditions checked are those conditions that need to be satisfied by all the rules registered under the head.  Here, by `head', we mean either an adhikāra or a component passed on by anuvṛtti. Now top level rules are those rules which observe the environment directly and get notified whenever the environment changes. For a rule, if the environment satisfies its conditions, it will be added to the candidate list. But if the environment satisfies the conditions that is applicable to an entire rule group, then the environment object is passed on to the next level and this continues till an exception or specific rule is encountered or else returns back to where the default rule resides. By this model, we can employ conflict resolution at each level, and resolve some of them locally and only rules that have no common head at any level come to the candidate list at top-most level, from where the winner rule will be selected.
\\
Once a winner rule is selected, the rule's intended action is executed first and then its parent object is called which performs its relevant portion in execution, if any. This continues until all the rules in hierarchy are called. It is to be noted that many a times certain rules like the adhikāra rules do not have anything to execute of their own; in such cases the rule object just passes on the environment to its parent object. By this design, redundancy of hard coding the same rules again and again per rule object is saved, just like the way anuvṛtti helps a person to avoid repeating the rules when reciting Aṣṭādhyāyī.

\begin{figure}[h]
    \centering
	\includegraphics[width=\textwidth]{fullImp}
    \caption{ Triggering schema.}
    \label{fig:fullImp}
\end{figure}


\\
\subsubsection{Working}
\label{sect:woring}
Let us consider the working of the system with reference to affixation for semantic relation {\skt अपत्यम्}, i.e. the patronymic relation. Figure \ref{fig:tadrule} shows the trace for the affixation process of Taddhita affix when the semantic relation is patronymic and the stem is {\skt चटका}. In Figure \ref{fig:tadrule}, the solid lines show inheritance hierarchy between the rule classes. The dashed line on the left of each block shows traversing of the hierarchy by triggering of rules from head to specific rules. The traversal checks for eligible rule to apply on environment within the rule group, and this can be called as the checking phase. The dotted lines on the right of each block show the trace of rules that get executed. The starting node, i.e. the node that heads the dotted edge with label 1 is the exact rule that gets executed and other nodes in the path show those rules that have been executed due to anuvrtti. This can be called as the execution phase. As an example let us consider the case where the environment is initialized with {\skt चटकायाः अपत्यम्}. The triggering starts from head rule at the top level i.e. from  {\sl A.3.1.1} to rule  {\sl A.4.1.128} as shown in Figure \ref{fig:obsUML}. Here in rule {\sl A.3.1.1}, it does not have any condition to check, so it directly notifies all of its direct descendants. Now among the direct descendants, rule {\sl A.4.1.1} checks for presence of any of the two affixes {\skt ङि, आप्} or if the environment has a prātipadika in it, i.e. it checks for conditions mentioned directly in the rule. As it is a prātipadika, the condition will evaluate to `true',and all its descendants are notified. In due course, {\sl A.4.1.76}, {\sl A.4.1.83} are also notified. These rules as well do not have any extra checks as they are adhikāra rules and hence all its direct descendants are notified. When {\sl A.4.1.92} is notified, it checks for semantic condition and the checking turns out to be true for {\sl A.4.1.92}, while the checking will evaluate to `false' for all of its sister nodes, i.e. other direct descendants of {\sl A.4.1.83}. The special case rules registered under {\sl A.4.1.92} are notified, of which {\sl A.4.1.128} satisfies the remaining conditions. As it does not have any rules registered to it, it becomes the terminal node and hence it is added to the candidate list. Since for this case no other rule is contesting, the rule emerges winner and starts its execution from {\sl A.4.1.128.} The rule adds the affix {\skt ऐरक्} to environment, and passes the environment to its parent class i.e. {\sl A.4.1.92}. {\sl A.4.1.92} does not have anything to execute of its own, so it simply passes environment to {\sl A.4.1.83}, which checks if any affix is already attached, as the affix `{\skt ऐरक्}' is attached in this case, no action is performed. The environment gets passed to parent node of each rule finally this terminates at top level rule {\sl A.3.1.1}. Now consider the derivation of {\skt उपगोः अपत्यं}. As with the case of {\skt चटकायाः अपत्यं}, the path of the rules checked for eligibility of rule application remains the same till rule {\sl A.4.1.92} is reached. Once {\sl A.4.1.92} is reached it will notify all of its descendants as well. But since no rule will find its application, {\sl A.4.1.92} will become the final node of the path here. It is added to candidate list, which while executing will simply call the parent rule {\sl A.4.1.83}. {\sl A.4.1.83} checks for presence of any new Taddhita affix in the environment. If the check evaluates to false, i.e. if no new Taddhita affix is found, {\sl A.4.1.83} treats this as default case scenario and attaches {\skt अण्}, the default case affix to environment. After each execution of a rule, the system checks for presence of any new assignment of `technical term' or else all rules in the top level are notified as discussed in Section \ref{sect:intro-deri}.


\\
The arthādhikāra rules inherit from its corresponding pratyayādhikāra rules, apart from the ones already mentioned in Section \ref{orgTad}. When it comes to affixation, during the checking for eligibility of a rule to apply i.e at the checking phase, we need to traverse the  pratyayādhikāra rule, before an arthādhikāra rule is reached. Though a pratyayādhikāra rule is visited during checking, no action is taken there. The pratyayādhikāra rule simply passes the environment to all arthādhikāra rules which are its direct descendants. In fact for a single affixation, all the pratyayādhikāra rules get notified from its parent rule, and those rules in turn notify all their direct descendants as there is not enough information to select a single pratyayādhikāra at during the checking phase. So in effect, the process of affixation for taddhita starts by checking for the right semantic condition i.e at the arthādhikāra rules as it is in the case of traditional system of derivation. Before that, the other rules either simply pass on the environment to their descendants or check for conditions that is necessary for the process to qualify as a case for affixation under taddhita. The effect of pratyayādhikāra rule comes during the execution phase i.e at the applying of affix phase and not on the checking phase. During the execution phase the pratyayādhikāra which is parent to the winner arthādhikāra rule acts as the final gate that makes sure that the environment has the valid taddhita affix added to the environment before it reaches its parent. The rule checks if any taddhita affix is introduced by virtue of special case rules, and if no such execution has taken place, then the default affix is added to the environment. The environment is then passed on to higher level rules that takes care of other generic aspects about the environment.

     
\begin{figure}[h] 
    \centering
	\includegraphics[width=\textwidth]{tadrule2}
    \caption{Affixation under patronymic relation for {\skt चटका}}
    \label{fig:tadrule}
\end{figure}
  
  
  
  
\\

\subsection{Environment Representation}
The environment is an object which contains the data entities that take part in the derivation process. Entities can be stems, affixes, augments, characters or any of their properties. The most basic and atomic entity in the environment is another object called `śabda'. The environment also contains various instances of the class `śabda collection' , which contains a sequence of references to śabda objects along with a set of attributes that belongs to the collection. Instances of `śabda collection' are used to represent various technical terms that may be attributed to environment or a part of it. Figure \ref{fig:enc} shows how the environment is set up.  Figure \ref{fig:enc} shows the environment after the affixation of Taddhita affix {\skt अण् }. As already seen in Section \ref{sect:woring}, the Taddhita affixation happened due to presence of technical term prātipadika. Now the technical term prātipadika is modeled as an attribute of the environment object, and it is an object itself of the class `śabda collection'. It contains references to sequence of all the śabda objects, which is collectively eligible for the technical term prātipadika. Similarly inside `pratyaya' object, it has an attribute `it marker' which also is an object of `śabda collection' class called `it'. If you notice though the {\sl it} ({\skt इत्}) marker is {\skt ण् in अण्}, it is not the śabda's property that it is an {\sl it} marker. It is the property of pratyaya that gives the śabda {\skt ण्}, the property of {\sl it marker}. This notion is captured very well in the system. It is essential that we store them as attributes separately for further reference and usage in the derivation process. For example, consider the derivation process for āśvalāyana. The term āśvalāyana is formed from aśvala by affixing `phak' pratyaya. Here the `it' marker is `k', which will be stored in `it marker' object, and later it will be elided, and hence be removed from the `text value' of pratyaya object by application of rules {\sl A.1.3.3 and A.1.3.9} . In due course of derivation the pratyaya object will get a substitution of `āyana' for the remaining `pha' by rule {\sl A.7.1.2}. Now in order to complete the derivation process, rule {\sl A.7.2.118} should stand valid in one of the subsequent steps. Rule{\sl A.7.2.118} requires a Taddhita affix with k as `it' marker. If we had not stored this information as a separate attribute earlier, we would have lost this information and derivation would not have completed.  \\     In case of {\sl asiddhavat} rules as discussed in \newcite{subbanna09}, the environment makes a complete copy of itself; one object is used for checking the conditions while in the other object, all the operations are applied. Once the system returns back to siddha section, the copy used for checking the conditions is discarded. It is also to be noted that in the representation the space between entities are also śabda objects, representing the virāma ({\skt विराम}) as per the rule {\sl A.1.4.110} {\skt विरामः अवसानम्}.



\begin{figure}[h]
    \centering
	\includegraphics[width=0.8\textwidth]{environment}
    \caption{Representation of śabdarūpa object}
    \label{fig:enc}
\end{figure}

\\


\subsection{Rule Selection and Conflict Resolution}
\label{sect:confRes}

There are instances in Aṣṭādhyāyi where multiple rules, which we call as candidate rules, find their suitability to be applied on the derivation environment. In such cases, we need to employ mechanisms that help us in resolving the conflicts. There is little information about conflict resolution among candidate rules in Aṣṭādhyāyi, though commentaries on Aṣṭādhyāyi by other scholars do mention about such mechanisms. It may be the case that Pāṇini had assumed those principles which were prevalent in his time as a prerequisite to understand his treatise on grammar. But this has led to debates among the scholars resulting in different schools of thought. In the wake of such a scenario, we have decided to implement the conflict resolution module as a separate pluggable module in our system, so that we can try out different methods on which the scholars in general have come to a consensus. But our system internalizes one concept as a default standard, the rule {\sl A.1.4.2 } {\skt विप्रतिषेधे परं कार्यम्}. The rule is discussed in Aṣṭādhyāyi itself and the details of how it works is discussed in Section \ref{sect:gen}. From various commentaries on Sanskrit grammar, we have also considered the mechanism described in `paribhāṣenḍuśekhara' of `Nāgeśa' as `pūrvaparanityāntaraṅgāpavaḍānāmuttarottaram balīyaḥ' which is generally accepted among the scholsrs. This gives the following linear order.
\\
\noindent\makebox[\textwidth][c]{%
    \begin{minipage}{0.8\textwidth}
     {prior (pūrva) < subsequent (para) < obligatory (nitya) < internally conditioned (antaraṅga) < exception (apavāda)  }
    \end{minipage}}
\\
\\
As it is evident from our discussions, we have centered our system design based on the notion of topicality, and the multilevel inheritance network is formed on the basis of topical head rules and the corresponding child nodes. This makes it possible for us to adopt the utsarga-apavāda principle of conflict resolution without any extra efforts. But when it comes to rules which do not fall under similar topical heads, it can be observed that sometimes proper rule selection does not take place. There are some instances in Taddhita section itself, where utsarga-apavāda principle is not sufficient to resolve rule selection conflict . To resolve such a scenario, we have applied the specificity hierarchy as mentioned in \newcite{scharf10a}. Specificity hierarchy deals with a priority wise ordering of rules based on the linguistic features present in the rule (or a combination of the same, if multiple entities are present) from the most concrete to the most abstract features. The linear ordering is as follows:
\\
\\
\noindent\makebox[\textwidth][c]{%
    \begin{minipage}{0.8\textwidth}
     {Phonetics < Phonology < Morphological < Semantic \\ }
    \end{minipage}}


\\
\\
The specificity of a rule is determined by the individual specificity aspects of entities that are present in a rule as pre-conditions to be satisfied. It is also to be noted that within the entities with the same specificity, finer granularity may be present. For instance, in the apatya semantic sense in the Taddhita section, there are rules that state conditions for the presence of semantic sense of three varying degree of specificity, {\sl apatyam, gotra and yuvām}, and it goes without saying that all the three fall under the same specificity hierarchy of `semantic'. But amongst these, gotra is more specific than apatyam, and yuvām is more specific than gotra. Hence when two rules find their application in an environment, where one has apatyam as semantic sense and the other has gotra as the semantic sense, the one with gotra specification will emerge as the winner rule even if the former rule comes after the later rule as per the Aṣṭādhyāyi sūtra ordering. Just like in the case of topicality, there are no explicit markings available in Aṣṭādhyāyi to identify the specificity. We need to encode the same in our rule classes explicitly, similar to the treatment given to topicality in our implementation. We have implemented specificity hierarchy for the apatya section in our prototype system and that has improved the results substantially which will be discussed in Section \ref{chapter 5}. 


We will be discussing the effect of applying these conflict resolution methods in Taddhita section and in other specific instances which are outside the scope of Taddhita in Section \ref{sect:gen}, to establish the system's effectiveness as an automated system for simulation of the entire Aṣṭādhyāyi.  
\\
\section{Derivation of a Derivative Noun}
\label{sect:egderi}
In this section we will show how the nominal stem {\skt औपगव} is derived in the system.
In section \ref{sect:woring}, the affixation is already shown. However, some of the finer details regarding post processing after execution of the rule are not discussed, which we will be doing in this step by step walk-through of the derivation. Please refer to Table \ref{derivation-table} for state of environment after each rule is applied.
\begin{itemize}
\item  Affixation as shown in section \ref{sect:woring}. Here the user input ``{\skt उपगु ङस् अपत्यं}'', has led to affixation of desired affix {\skt उपगु ङस् अण्}. As the affix got added to the environment in the form of `pratyaya' object as shown in Figure \ref{fig:enc}, two more attributes were also added to the `pratyaya' object. The two attributes are `upadeśa' and `Taddhita'. Contrary to as discussed in section \ref{sect:woring}, the attributes are not objects by themselves. This is because the pratyaya object bears reference to the exact sequence of śabda objects as these two attributes and hence separate object instantiation is not required. The prātipadika object which is an attribute of the environment, but signifying the base nominal {\skt उपगु ङस्}, i.e. the stem upagu in genitive case, goes to ``processed'' state. 

\item Since there are two new attributes that are not yet in processed state in one of the objects of environment, instead of notifying the top level rules, system takes in the attribute upadeśa which is a technical term and is assigned to pratyaya object, and triggers corresponding rule group (in this case the rule group headed by {\sl A 1.3.2}). This leads to instantiation of `it marker' object as shown in Figure \ref{fig:enc} and subsequently to rule {\sl 1.3.9} that leads to elision of the {\sl it} marker. Though the marker is elided, neither the object reference nor the śabda object, the marker is referring to, is removed from the environment. In fact the śabda object keeps the marker information ({\skt णित्}) as a separate attribute.

\item Now since no more rules can be triggered automatically, the system notifies all the top level rules of which, top level rule {\sl A.1.2.46} finds its eligibility due to presence of attribute `Taddhita'. Though {\sl A.1.2.46} gets Prātipadikam { \skt प्रातिपदिकम्  } from {\sl A.1.2.45} as anuvṛtti, still it is not modeled as a descendant of {\sl A.1.2.45}, as it does not represent topicality or common condition. The effect of the anuvṛtti passed on here is that of assigning of the term, which is an effect on the rule, not a cause or condition on the rule. Environment gets a new attribute Prātipadika.

\item No specific rule group can be invoked by Prātipadika attribute. All top level rules are notified, of which only {\sl A.2.4.71} finds its eligibility, which also happens to be a top level rule. This results in removal of {\skt ङस्} 

\item Similarly, the system will get the object `{\sl aṅga}' (for the technical term aṅga) as an attribute to environment, after the rule {\sl A.1.4.13} find its eligibility, and the system will directly notify the rule group headed by {\sl A.6.4.1} {\skt अङ्गस्य}. {\sl A.7.2.117} will find its eligibility to apply. The exact same steps are executed for subsequent operations, where the technical terms {\skt भ and संहिता } are assigned due to the rules {\sl A.1.4.18} and {\sl A.1.4.109} respectively and by virtue of those attributes to environment, rules {\sl A.6.4.146} and {\sl A.6.1.78} respectively are executed resulting in the desired final form {\skt औपगव}.

\end{itemize}
\section{The Schema as a General Schema for Modelling Aṣṭādhyāyī}
\label{sect:gen}

In section \ref{fig:fullImp}, we have seen the working of the system. In this section we will be considering rules that are outside of Taddhita section. \newcite{scharf10a} discusses five cases in which conflict of application occurs between two competing rules. In his paper, Scharf talks about conflict between rules {\sl A.6.1.87 } and {\sl A.6.1.88} where the domain of application of {\sl A.6.1.88} is properly contained within the domain of application of rule {\sl A.6.1.87}. Here {\sl A.6.1.88} should emerge as the winner rule, or else 6.1.88 will never be applied to any context. In our system {\sl A.6.1.87} is a direct descendant of {\sl A.6.1.84} which is a direct descendant of {\sl A.6.1.77}. The only aspect that is passed from {\sl A.6.1.77} as part of inheritance is {\skt अचि}, which is nothing but checking for a vowel as a right context. One might argue that {\sl A.6.1.84} does not have any relevance for this checking, but {\sl A.6.1.84} is an adhikāra rule and hence the execution will never stop at the rule; instead it will surely traverse down to one of the descendant rules. Also, its domain of influence is completely within the set of rules which is under the influence of rule {\sl A.6.1.77}. Now {\sl A.6.1.87} is one such rule. It is also evident from this instance as to how the rule is inheriting a set of mutually exclusive features and conditions by multilevel inheritance, avoiding the need for multiple inheritance. {\sl A.6.1.88} is also one such rule, but it needs an additional checking of condition which is checked also at {\sl A.6.1.87}. So in our system {\sl A.6.1.88} inherits from {\sl A.6.1.87} and becomes descendant of {\sl 6.1.87} by virtue of the anuvṛtti of {\skt आद्}. So whenever environment object is passed on to {\sl A.6.1.87}, it first checks presence of {\skt अ or आ} as the left context and then notifies all its registered rules including {\sl A.6.1.88}. If the rule is applicable to {\sl A.6.1.88}, i.e., if the environment satisfies all the conditions as demanded by {\sl 6.1.88} then it gets activated. So in addition to check for left context as per {\sl A.6.1.87}, {\sl A.6.1.88} also checks for {\skt एच्} as right context, which is applicable only to itself. This check is further restricting the scope of application to what occurred at rule {\sl A.6.1.77} where the checking was for {\skt अच्}. If this evaluates to `true', it will block the direct application of {\sl A.6.1.87} i.e. guṇa will not happen there, but instead vṛddhi will take place. If no rules turn out to be eligible for application, then only {\sl A.6.1.87} will perform the application of guṇa over the environment. Please note that the checking of other conditions that are applicable to these rules are not discussed here as those conditions are obtained by virtue of anuvṛtti and are being checked in the parent rules.
\\
Now let us consider a case where partial blocking occurs when the rules {\sl A.6.1.77} and {\sl A.6.1.101} are in conflict. Our system deals with this in the same manner as we dealt with simple blocking. Rule {\sl A.6.1.101} inherits {\skt अचि}, i.e. element of {\sl ac} pratyāhāra, as right context. One thing to notice here is that the rule {\sl A.6.1.77} also checks for {\skt इकः}, i.e., element of {\sl ik} pratyāhāra in the context. But this is not carried forward as anuvṛtti. Now this rule is modeled as follows. The environment is passed onto {\sl A.6.1.77} and then it first checks for {\skt अचि}. Since only this is carried as anuvṛtti, once this condition evaluates to `true', the rule notifies all rules registered with it. It waits for any of its descendants to claim eligibility. If no rule claims eligibility then the rule checks for additional condition of {\skt इकः} and if the condition evaluates to `true', it claims the eligibility. In case of conflict between {\sl A.6.1.77} and {\sl A.6.1.101}, the desired rule is {\sl A.6.1.101}, but A.6.1.101 is a descendant of {\sl A.6.1.77}, so it will claim its eligibility and hence {\sl A.6.1.77} will be blocked from claiming its eligibility as per our system. From these examples it is evident that the system, without even using any extra conflict resolution techniques, can resolve the conflicts here. These examples demonstrate that the system internalizes rule {\sl A.1.4.2} {\skt विप्रतिषेधे परं कार्यम्}. Now consider the case when there is a conflict between the rules {\sl A.7.3.111} and {\sl A.7.1.73}. Here both the rules belong to domain of aṅga, i.e., rule {\sl A.6.4.1}. Neither of the rules inherit from the other, and hence both of them are at sibling level and have a common parent at rule {\sl A.6.4.1}. In such a case where both the rules claim eligibility, the conflict which is at the level of rule {\sl A.6.4.1}, needs to be resolved. The desired rule in such a case is {\sl A.7.1.73}. The important point to be noted here is that though the system internalizes the concept of {\sl A.1.4.2}, it still does not claim {\sl A.7.3.111} as the winner rule. Instead the system will pass both the rules to the conflict resolution method coded as a separate function in the system, once it reaches the object for the rule {\sl A.6.4.1}. We will be trying out different conflict resolution methods mentioned in authentic texts and will be reporting the accuracy of each method or various combinations of these methods on different data samples. Other conflict cases discussed in \newcite{scharf10a} are not discussed here as those fall into one of the scenarios already discussed.
\\
\section{Evaluation Results}
\label{chapter 5}


\subsection{Evaluation Framework}

For the evaluation, we have implemented the entire apatya section in the Aṣṭādhyāyi. The apatya section consists of rules from {\sl A.4.1.92 to A.4.176} which deal with the affixation rules for stems that need to be used along with semantic sense of apatyam (with its subtypes gotra, yuvām) or `the descendant of' semantic relation. For the proper execution of these rules, we were required to implement other rules that come in the multilevel inheritance hierarchy like the pratyayādhikāra rule {\sl A.4.1.83} and its exceptions as well as those outside the Taddhita section like vṛddhi, guṇa and other associated rules. We have selected 60 input cases that cover the whole span of `apatya' section and obtained the output after affixation from the system.  
\\ \\
A web based survey interface was used for the human judgment experiment.\footnote{The evaluation URLs are :- Set 1 - http://goo.gl/forms/Lj5z3UzUr9, Set 2 - http://goo.gl/forms/2O31D6gF83, Set 3 - http://goo.gl/forms/goWgwMnYct}. We divided our inputs into sets of 3, each set having 20 input cases. We then reached out to the experts from Sanskrit linguistics to participate by evaluating one or more of these sets. A total of five experts from the linguistics and Sanskrit computational linguistics fields participated in the evaluation. For a given input case, the following details were provided to the experts: the input string, conditions and assumptions that were required for the correct derivation, winner rule number and the sūtra contents, candidate rules which had conflicts and finally the output form. The experts were asked to do a binary evaluation of the correctness of output, based on the input and other constraints provided. In case of difference of opinion among the experts, we took the majority opinion as the truth value after weighing in the remarks provided by all the experts.
\\ \\
\begin{figure}[h]
    \centering
	\includegraphics[width=0.6\textwidth]{evalPic}
    \caption{Snapshot of the evaluation framework}
    \label{evalFig}
\end{figure}


The results of the evaluation are shown in Table \ref{evalTab}. From among the 60 input cases, a total of 10 cases were evaluated as incorrect. As already discussed in Section \ref{sect:confRes}, the system has internalized vipratiṣedha as its default conflict resolution mechanism. The outputs were obtained with no other conflict resolution mechanism being employed. 10 cases resulted in wrong output. We later implemented the specificity hierarchy for conflict resolution and then obtained the outputs again for the same set of input cases. This time, the number of incorrect output cases were reduced to 4. We will be discussing some of the wrong output cases in Section \ref{wrongCases}.  

\begin{table}[h]
\caption{Evaluation results for the experimental setup}
\label{evalTab}

\resizebox{0.9\textwidth}{!}{%
\begin{subtable}[t]{4in}
\caption{Details about the experimental setup}

\begin{tabular}{lc}
\hline
\multicolumn{1}{|l|}{Number of Input cases}                                                                                                  & \multicolumn{1}{c|}{60} \\ \hline
\multicolumn{1}{|l|}{Evaluators Participated}                                                                                                & \multicolumn{1}{c|}{5}  \\ \hline
\multicolumn{1}{|l|}{Inputs per evaluator}                                                                                                   & \multicolumn{1}{c|}{20} \\ \hline
\multicolumn{1}{|l|}{Numebr of Correct cases}                                                                                                & \multicolumn{1}{c|}{50} \\ \hline
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Number of Wrong output \\ (with no external conflict resolution)\end{tabular}}               & \multicolumn{1}{c|}{10} \\ \hline
\multicolumn{1}{|l|}{\begin{tabular}[c]{@{}l@{}}Number of wrong outputs\\ (with specificity hierarchy for conflict resolution)\end{tabular}} & \multicolumn{1}{c|}{4}  \\ \hline
                                                                                                                                             & \multicolumn{1}{l}{}   
\end{tabular}
\end{subtable}

\begin{subtable}[t]{3in}
\caption{Accuracy of the evaluation results}
\begin{tabular}{|l|c|c|}
\hline
Evaluation                           & \multicolumn{1}{l|}{Accuracy} & \multicolumn{1}{l|}{Error} \\ \hline
With no external conflict resolution & 83.33                         & 16.67                      \\ \hline
With specificity hierarchy           & 93.33                         & 6.67                       \\ \hline
\end{tabular}
	\end{subtable}

}
\end{table}


\begin{itemize}

\subsection{Analysis of Wrong Cases and Other Special Cases.}
\label{wrongCases}

\item For inputs {\skt उत्स ङस् अपत्यम्, दिति ङस् अपत्यम्}, the rules that got applied were {\sl A.4.1.95 and \sl A.4.1.122} respectively which essentially look for the phonological properties. The correct rules to be applied for the instances are {\sl A.4.1.86 and A.4.1.85} respectively. Though these rules have the same topical heads, they are specified before the current winner rules in Aṣṭādhyāyi, and hence by principle of vipratiṣedha, the former got preference over the desired ones. But if we observe they are more specific than the current winner rules. The correct rules have specificity at the morphological level because the rules mention some stems, while the current winner rules have specificity only at the phonological level. Please note that all the mentioned rules (winner and desired) carry entities that bear semantic specificity. But, since all the rules have that notion of semantic specificity, the effect from this notion is nullified here.

\item For inputs {\skt गर्ग ङस् गोत्र, कपि ङस् गोत्र}, the rules that got applied are {\sl A.4.1.151 and A.4.1.122}, instead of the rules {\sl A.4.1.105 and A.4.1.107} respectively. Any rule in apatya section, or for that matter any rule under the `arthādhikāra' has a semantic specificity by default, which is the semantic sense. But in this case, the rules {\sl A.4.1.105 and 107} bear a finer level of semantic specificity of gotra, while the current applied rules deal with the  general case of apatya. Please note that gotra is a specific sub-type of apatya. So whenever the intended semantic sense is gotra, and if there exists a rule that is applicable and has gotra specification, then it should be applied if conflicting with a rule of apatya specification.

\item For the input {\skt पितृष्वसृ ङस् अपत्यम्}, ideally two output cases should appear, {\skt पितृष्वसृ ङस् छण्  and पितृष्वस् ङस् ढक्}. It is not rare in Taddhita derivation to see the applicability of multiple affixes for a single input case. But here the second output is the result of the rule {\sl A.4.1.133} {\skt ढकि लोपः}.The rule states that the final {\skt ऋ} in {\skt पितृष्वसृ} will be elided. Now no other rule mentions about affixation of {\skt ढक्} for the given input case. While implementing the rule {\sl A.4.1.133}, an assumption is made that the at first affix {\skt ढक्} should be introduced and then the elision operation should be performed. The basis of this assumption comes from the argument by many of the scholars that Pāṇini, by specifying about the condition in {\sl A.4.1.133} implies that the affix {\skt ढक्} should be introduced \cite{rsbook}. It is argued that for the sake of brevity, Pāṇini explicitly did not mention the rule, but if the affixation is not implied then there is no purpose for the rule.\footnote{Our implementation has followed this assumption.}

\item In case of rule {\sl A.4.1.122}, the rule is applicable, specifically for a nominal that has an `i' as its last phonological entity but not by virtue of {\skt इञ्} affix attached to them. Such rules cannot be triggered unless and until one has prior knowledge about the affixes that the word-form obtained during its formation. For this purpose while automating, we should either keep a list of words beforehand, or else there should be some mechanism to store the extra information. Our system currently stores a list of stems to tackle the issue as we will be taking text inputs from the user. But what is more significant is that our 'śabdarūpa' object provides the functionality to store all those extra information like the `it' marker {\skt ञ्} which otherwise will not be present in the final word-form. This implies that when we reuse a word form for derivation from our own system, we utilise those extra information which are stored in the data structure.

\end{itemize}
\\

\section{Discussion and Conclusion}
\label{sect:conc}

\subsection{Bottlenecks in Automating the Astadhyayai}
\label{bottlenecks}

Our attempt was to automate the Taddhita section in Astadhyayai which primarily deals with affixation of derivational nouns. It is evident from the discussions so far, that Pāṇini uses a rich set of linguistic features in formulating rules and conditions to check for, before affixation. From the discussion about specificty hierearchy, we can see that the entire Aṣṭādhyāyi has used variety of linguistic features ranging from phonetic to semantic features. Along with such features, Pāṇini occasionally used the intention of the speaker as a condition to be satisfied as well. For example, if we consider the rule {\sl 4-1-147 \skt गोत्रस्त्रियाः कुत्सने ण च }, the term {\skt कुत्सन} signifies `reproach'. It is the intention of speaker whether or not to address someone by referring through the `descendant of' relation in a disrespectful way. Such an aspect cannot be captured beforehand. So while implementing the automated system, we either had to generate all the alternatives, whenever the condition to be satisfied is an intention, or else ask for human intervention to clarify the intention. We proceeded with the later method as the former strictly does not adhere to the intended output derivation of the grammar. 
\\ \\ 
In Section \ref{wrongCases}, the first case can raise a question about our assumption in the specificity hierarchy. The desired rule for the instance discussed is {\sl A.4.1.86} and the conflicting rule is {\sl A.4.1.95}. Now if we look into the rule contents, we can find that rule {\sl A.4.1.86} does not come under any `arthādhikāra', and only comes under a `pratyayādhikāra' and {\sl A.4.1.95} has an `arthādhikāra'. It can be argued that {\sl A.4.1.95} has a higher priority as per specificity hierarchy as it has a semantic condition, but the desired rule does not have a semantic condition, but only a morphological condition. These observations motivated us for the existing assumption. The linguistically motivated counter argument is that if we go by the former argument, then the rule {\sl A.4.1.86} will never find its applicability. From the implementation aspect of view, the default affix rule {\sl A.4.1.83} and its exceptions which include {\sl A.4.1.86} as well, get to apply the prefix after a suitable semantic relation is found, which are later rules like {\sl A.4.1.92}, which is in fact a semantic condition and this nullifies the effect. The assumption still needs to be validated in other similar rule conflict cases outside of Taddhita section.
\\ \\
In Section \ref{sect:gen}, we have talked in length about how the system has internalized the rule {\sl A.1.4.2}. Among different type of rules that Pāṇini had formualted in his treatise, {\sl A.1.4.2} is a metarule, that describes about how other rules are to be interpreted. There are many such metarules in Aṣṭādhyāyi like {\sl A.1.1.66, A.1.1.49 } etc. In our system we have internalised those concepts and directly applied those in our implementation logic. So in our implementation the metarules are assumed to be known and the metarules are followed, but there is no explicit entity defined for the same. Further research is required to code meta-rules as separate entities, to have their presence stated explicitly.

\subsection{Conclusions and Future directions}
\label{subDisc}

The proposed schema, which is primarily aimed at the automated generation of derivative nouns, or what is called as Taddhita section, adopts a completely object oriented approach in modeling the system. To the best of the authors' knowledge, the system is first of its kind that focuses specifically on modeling Taddhita section of Aṣṭādhyāyī. The system not only focuses on generation of correct final forms but also in producing the correct sequence of rules applied for the entire derivation process. This approach doubles the system as a tool for pedagogy, where a learner can use the system to learn about the derivation process by trying out nominal of his choice, rather than restricting himself to a fixed set of textbook examples or a set of stored samples. As already discussed, the system facilitates in adopting and trying out various conflict resolution methods for rule selection, which can be programmed separately and then invoked from the system. As there is no consensus over one correct set of resolution methods, the proposed system can be used as a validation tool for verifying the accuracy of different conflict resolution methods that have been mentioned in various scholarly works. In fact, we have not yet mentioned about one of the major areas of application for the proposed system. Since the system is essentially generating nouns (or adjectives) from other nouns (or adjectives) based on semantic relations, the system can be used to obtain relations between different nominals in an automated way. This kind of information can be used to supplement available lexical resources like IndoWordNet for sanskrit \cite{pushpak10} and also to provide supplementary information in dictionary entries for lexical databases as described in \newcite{huet2004design}.
\\



Our system forms rule groups as Directed Acyclic Graphs (DAG), analogous to as \newcite{subbanna09} suggests. But our notion of topical rule groups  arises from the notion of topicality by virtue of anuvṛtti, while \newcite{subbanna09} attempts to form the topical rule groups from general-exception rule concepts. The approaches in group formation need to be studied further, in order to comment on the commonality of the DAGs so formed, but \newcite{subbanna09} do not talk about the attempts to model their concept in implementation. As each rule class implements precisely what is mentioned in the rule, and the implied portion is inherited by virtue of anuvṛtti from the parent class, the system can keep a trace of all the parent rules that have acted upon the environment, due to triggering of a particular rule. This gives the learner a much more detailed view of triggering of rules. The environment data structure is also an object based implementation, environment mostly stores properties and does not have methods or functions that model any aspect of Aṣṭādhyāyī. The functions or methods implemented in environment are mostly for programmatic conveniences or adding functionality to the system front-end. This makes the set up of environment comparable to the set up as in \newcite{scharf14} which is primarily an XML representation. The conversion of Objects to XML schema is a well addressed task in IT World \cite{jain2002xml}. Hence one can also think of developing a schema to transfer the data entities used in one system to the other, as \newcite{scharf14} tries to model the entire Aṣṭādhyāyī.  

\section*{Acknowledgments}

We would like to extend our gratitude towards \textbf{ Dr. G{\'e}rard Huet, Dr. Peter Scharf and Dr. Amba Kulkarni } for their support and valuable inputs from the discussions we had related to the work. We would also like to thank the experts, \textbf{ Ms. Sukhada, Ms. Anuja Ajotikar, Ms. Tanuja Ajotikar, Mr. Pavankumar Satuluri and Mr. P Sanjeev} for participating in the system evaluation we had conducted and also for sharing their valuable comments.  

% include your own bib file like this:
\bibliographystyle{acl}
\bibliography{myWork}
\end{document}
